## 1. Прямая (абсолютная) адресация
**Суть:** Адрес операнда указан непосредственно в команде.
```asm
MOV AX, [0x1234]  ; Загрузка из ячейки 0x1234
```
**Характеристики:**

- Требует полного адреса в команде → увеличивает размер кода
    
- Медленный доступ (требуется обращение к памяти)
    
- Используется для глобальных переменных
    
- В современных CPU почти не применяется из-за неэффективности
    

## 2. Косвенная адресация

**Суть:** Адрес операнда хранится в регистре/ячейке памяти.

**Варианты:**
```asm
MOV AX, [BX]      ; Регистровая косвенная (адрес в BX)
MOV CX, [[0x100]] ; Косвенная через память (двойное разыменование)
```
**Особенности:**

- Гибкость (динамическое вычисление адресов)
    
- Поддержка указателей и сложных структур данных
    
- Требует дополнительного обращения к памяти
    

## 3. Регистровая адресация

**Суть:** Операнд находится в регистре процессора.
```asm
ADD R1, R2, R3  ; R1 = R2 + R3
```
**Преимущества:**

- Максимальная скорость выполнения
    
- Короткие команды
    
- Ограничение: конечное число регистров (обычно 16-32)
    

**Применение:** Локальные переменные, промежуточные результаты

## 4. Непосредственная адресация

**Суть:** Операнд содержится в самой команде.
```asm
MOV EAX, 42     ; Загрузка константы
AND BL, 0xF0    ; Маскирование битов
```
**Особенности:**

- Самый быстрый доступ
    
- Ограничение на размер данных (обычно ≤ размера регистра)
    
- Используется для констант и мгновенных значений
    

## 5. Относительная адресация

**Суть:** Адрес = базовый регистр + смещение.
```asm
MOV AX, [BP-4]    ; Доступ к локальной переменной
LDR R0, [PC, #8]  ; ARM: загрузка относительно PC
```
**Ключевые моменты:**

- Позиционно-независимый код
    
- Эффективный доступ к:
    
    - Локальным переменным (относительно BP/SP)
        
    - Данным в сегменте кода (относительно PC)
        
- Основной способ адресации в RISC-архитектурах
    

## 6. Индексная адресация

**Суть:** Адрес = база + индекс * масштаб.
```asm
MOV AL, [SI+0x100]      ; x86: база + смещение
MOV R0, [R1, R2, LSL #2] ; ARM: R0 = *(R1 + R2*4)
```
**Применение:**

1. Обработка массивов:
```asm
; Цикл по массиву (x86)
MOV SI, offset array
MOV CX, 10
loop:  
MOV AL, [SI]  
INC SI  
LOOP loop
```

2. Доступ к полям структур:
```asm
; R1 = адрес структуры, R2 = смещение поля
LDR R3, [R1, R2]
```
## Сравнительная таблица

| Способ        | Формат примера       | Тактность  | Гибкость | Типичное применение              |
| ------------- | -------------------- | ---------- | -------- | -------------------------------- |
| Прямая        | `MOV [0x100], AX`    | 4-5 тактов | Низкая   | Глобальные переменные            |
| Косвенная     | `MOV AX, [BX]`       | 2-3 такта  | Высокая  | Указатели, динамические данные   |
| Регистровая   | `ADD R1, R2, R3`     | 1 такт     | Низкая   | Локальные переменные             |
| Непосредств.  | `MOV R1, #42`        | 1 такт     | Низкая   | Константы                        |
| Относительная | `LDUR X0, [X1, #8]`  | 2 такта    | Средняя  | Стек, позиционно-независимый код |
| Индексная     | `MOV EAX, [EDI*4+8]` | 3 такта    | Высокая  | Массивы, структуры               |
